# 1 #

### 错误：RE ###

### 错误原因：

```c++
if (size >= 3) {
	a.erase(left, size);
    play(left - 1);
}
```

在本段代码中，如果消除发生在字符串开始处则left == 0, 此时play(left - 1)的函数调用(见下方)会引起对字符串的非法访问。

```c++
void play(int rank) {
    int left = rank;
    int right = rank;
    char color = a.at(rank);//rank < 0
```

### 测例：

AABBA
1
2 B

### 构造思路：

使消除发生在字符串开始处(本例中为A的消除)，便会引起上述非法访问。

# 2 #

### 错误：RE ###

### 错误原因：

若将字符串a全部消除，以下代码对a的访问将抛出异常。

```c++
void play(int rank) {
    int left = rank;
    int right = rank;
    char color = a.at(rank);//a为空串时出现错误
```

### 测例：

AABBA
1
2 B

### 构造思路：

将a全部消除，变为空串。

# 3 #

### 错误：TLE ###

### 错误原因：

在插入或消除过程中，完成寻址、增删操作的总复杂度达到O(n)，因此程序的总复杂度达到O(mn)，最终超时。

### 测例：

见OJ最终版本提交的03.in。

### 构造思路：

向长度足够大的字符串中进行次数足够多的插入即可。

# 4 #

### 错误：WA ###

### 错误原因：

```c++
while (left > 0 && a.at(left) == color) --left;
while (right < a.size() && a.at(right) == color) ++right;
```

上方代码中，在得到最终需要消除的字符时，在找到第一个与消除颜色相同的字符后left最后一次减一并到达最后一个与消除颜色不同的字符。

```c++
if (size >= 3) {
	a.erase(left, size);//多消除一个字符
    if (left >= 0 && left < a.size()) {
		play(left);
    }
}
```

从而，在消除字符时会多消除正确区间左侧的一个字符。

### 测例：

AABB
1
4 B

### 构造思路：

在消除区间以左存在其他不需消除的字符即可，此时该区间左侧一个字符被消除。

# 5 #

### 错误：WA ###

### 错误原因：

初始字符串可能为空串，此时所示代码无法正常完成输入。

```c++
cin >> a;//无法输入空行
int m = 0;
cin >> m;
```

### 测例：



1
0 A

### 构造思路：

输入空行，程序无法正常输入。

# 6 #

### 错误：WA ###

### 错误原因：

没有判断插入后是否超过块大小上界```plen_bound```，而由于二维数组连续存储，可能发生块数组越界后覆盖下一个块数组的情况。

### 测例：

见OJ最终标记提交的06.in。

### 构造思路：

在插入过程中使块数组越界，引起覆盖。

# 7 #

### 错误：WA ###

### 错误原因：

```c++
l.second--;
dis++;
if (l.second < 0 && l.first >= 0) { //应当使用while；如果上一块长度为0则无法进入正确的块
	l.first--;
	if (l.first >= 0)
		l.second += plen[l.first];
	}
}
```

所示代码为得到消除区间时l(指示区间左界)进入上一块的操作，没有考虑到在上一块消除过一整块之后该块长度变为0的情况，此时l无法越过该空块进入正确的一块。

### 测例：

见OJ最终标记提交的07.in。

### 构造思路：

先将某一块消除，之后在下一块插入字符，使得下一块与上一块之间进行消除，此时l无法进入上一块。

# 8 #

### 错误：WA ###

### 错误原因：

```play()```函数中没有考虑连消

### 测例：

AABBA
1
2 B

### 构造思路：

实现连消即可。

# 9 #

### 错误：RE ###

### 错误原因：

```c++
if (l.first >= 0) {
	plen[l.first] = l.second + 1;
}
```

没有考虑l, r在同一块的情况；此时所在块长度已经因l在此缩减为l及其前驱(见上方代码)，此时在对r及其后继进行删除操作(见下方代码)时会将块长置为负值。

```c++
if (r.first < pn) {
	int len = plen[r.first] - r.second;//r后续的长度
    //若l,r在同一块此时plen[r.first] == l.second + 1 < r.second, len < 0
	if (len > 0) {
		memmove(&p[r.first][0], &p[r.first][r.second], len);
	}//把r之后的部分移动到该块开始处
	plen[r.first] = len;//可能<0
}//在r所在块进行消除
```

此时，在最终还原二维数组时(见下方)出现错误。

```c++
void p2a() {
    int copied = 0;
    for (int i = 0; i < pn; i++) {
        memcpy(&a[copied], p[i], plen[i]);//plen[i]为负时出错
        copied += plen[i];
    }
}
```

### 测例：

ABABABCCB
1
7 C

### 构造思路：

使l，r位于同一块(消除区间前后有其他字符且在同一块内)，从而引发上述错误。

# 10 #

### 错误：WA ###

### 错误原因：

```c++
//消除l,r之间的块
for (int i = l.first; i < r.first; i++) //应当为i = l.first + 1;
	plen[i] = 0;
```

所示代码在将l, r之间的块删除时也删除了l所在的块。

### 测例：

见OJ最终标记提交的10.in。

### 构造思路：

在两块之间消除，此时上方代码将l所在块长度置为0，最终还原时出现错误。











