# Lab 2 Hashfun 解题报告

## 1.哈希函数与冲突处理策略的实现 ##

1. 针对ascii编码的哈希函数

   采用2进制多项式哈希，以字节为单位计算哈希值。$ hash(str[]) = \sum_{i=0}^{n - 1} str[i] \times 2^i. $

2. 针对utf-8编码的哈希函数

   采用2进制多项式哈希，以utf-8字符为单位计算哈希值。在计算时首先根据首字节判断字符字节数，随后将除各字节起始固定位(如0,110,1110等)之外的bit(即各字节中真正有所不同的部分)取出得到字符对应值，最后以2作为基数计算字符串哈希值。$ hash(str[]) = \sum hash(utf8\_char_i) \times 2^i. $

3. 双向平方试探策略

   在策略结构中以成员变量记录试探偏移方向与双向试探次数，每次试探改变方向，每次正向试探增加次数。初始化时将方向设为正向，次数设为0；每次试探先消除上次反方向试探的影响，再进行本次试探偏移。具体细节见代码实现。

4. 公共溢出区策略

   将哈希表数组后半部分作为公共溢出区，若冲突位置不在溢出区则返回溢出区首位，在溢出区则向后一位。为此插入、查询调用哈希函数应以哈希表数组一半长度作为总长传参。具体细节见代码实现。

## 2.测试数据 ##

6个测试数据均以`i_j.txt`命名，其中i表示数据集(1来自poj.txt, 2来自hdu.txt)，j表示数据本身插入、查询次数的差异。j = 1的数据进行4000次插入，20000次查询；j = 2的数据进行12000次插入，12000次查询；j = 3的数据进行20000次插入，4000次查询。其中插入数据完全随机，以`std::set`记录防止重复；查询数据来自插入数据，同样完全随机产生。

## 3.结果分析 ##

1. 使用针对utf-8编码的哈希函数相比针对ascii编码的性能较差。尽管前者通过整体处理字符以避免相同字节表示不同字符的情况，并去除编码中重复部分而减少了冲突，但可能由于操作较为复杂而弊大于利。
2. 双向平方试探性能显著优于线性试探。线性试探解决冲突的范围相对集中且连续，数据堆积现象严重，易于造成冲突；而双向平方试探通过离开局部范围规避了这种问题。
3. 封闭散列优于开放散列，后者更适用于冲突较少的数据。
4. 可能导致字符串哈希值较为接近，解决冲突时试探次数增加。
5. 例如：只有0和1组成的字符串到数的映射关系可以使用二叉树存储，从根节点开始，每一位为0则进入左孩子，为1进入右孩子，串结束时得到当前节点存储的数据，避免了冲突而更加高效。



