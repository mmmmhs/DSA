# Lab 3 BBST 解题报告

## 1.数据结构及复杂度 ##

实现了AVL树与伸展树两种数据结构。

具体地，首先实现了二叉树节点`BinNode`结构与二叉搜索树`BST`基类，包括了寻找节点直接前驱、直接后继的`pred()`与`succ()`函数，精确查找节点的`searchExact()`虚函数与查找不大于数据的最大节点的`search()`虚函数，以及更新节点高度的`updateHeight()`函数。

为实现AVL树，BST类还需要实现“3+4”重构函数`connect34()`与`rotateAt()`。此后，继承BST类实现AVL类，实现插入与删除函数。

为实现伸展树类`Splay`，具体需要实现将节点伸展至根的函数`splay()`、插入与删除函数，并重写`search()`与`searchExact()`函数以加入伸展操作。

两种数据结构的插入、删除与查找时间复杂度均为`O(logn)`(伸展树为分摊意义下)，空间复杂度为`O(n)`。

## 2.测例设计 ##

共设计了两种测例：一种针对泛用性好的AVL树，一种针对伸展树特性。
使用`std::set data_insert`记录插入情况，避免重复插入；使用`std::vector data_access` 管理可用于查找、删除访问的数据。

AVL树维持全树平衡因子在$ \pm1 $之间，因此对各种数据都具有较为稳定的性能。
针对AVL树的测例完全随机产生，其中插入、查找、删除操作的比例大致为99:99:2。

伸展树能够将被访问的节点伸展至根部，使其在下一次被访问时所需时间减小，因此对于需要重复访问小范围数据的测例而言具有优势。
针对伸展树的测例设计思路如下：
为实现伸展树优势情况，测例中只访问了已插入节点的一部分，其数量为`access_num`，存储于`data_access`中。具体而言，是先产生随机数作为起始下标，在插入过程中将这一起始位置及其后连续的`access_num`个插入数据存储在访问范围内。为避免随机的插入操作对查找时伸展树结构的影响，将查找、删除与插入操作分离。查找操作分轮次进行，每一轮访问一个固定的节点，共访问`access_num`轮，最后将访问范围中的节点删除。

## 3.性能分析 ##

1. 在针对AVL树设计的测例下，AVL树性能显著优于伸展树。这是由于伸展时需要经历对树整体结构的大量更改，而完全随机的访问使伸展树的优势无法体现。
2. 在针对伸展树设计的测例下，伸展树性能相比AVL树较优。这是因为伸展树每轮只访问上次访问时被伸展至根的节点，在只访问少数节点时具有优势。



