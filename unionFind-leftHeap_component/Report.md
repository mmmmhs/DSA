# PA 3-4 Component 解题报告

## 1.数据结构 ##

- 并查集
- 左式堆

## 2.算法原理 ##

- 对每个连通分量，维护一个由其中点的权值组成的小顶左式堆。若规模超过k则不断出堆直至规模为k，从而堆中存储连通分量权值最大的k个点，堆顶即为第k大权值。
- 通过并查集记录各连通分量集合
- 初始各点均不相连，每输入一条边则通过并查集判断两点是否在同一连通分量中。若否，则合并对应集合与左式堆。
- 查询时通过并查集找到该点对应连通分量，返回左式堆堆顶即可。

## 3.实现要点 ##

1. 并查集查找采用路径压缩方法，将到达集合根路径上每个节点的父亲均设置为根以减小遍历次数
2. 并查集合并时，将规模较小的集合并入大集合，以减小操作次数
3. 保证堆合并与并查集合并方向一致，使并查集根节点始终与左式堆下标相同

## 4.解题过程中的问题与技巧

- 路径压缩时使用迭代代替递归，优化栈空间使用
- 通过数组统一管理左式堆与节点，便于准确访问

## 5.复杂度分析 ##

(1)时间复杂度

- 经搜索了解并查集单次操作时间复杂度可视为常数
- 左式堆规模为`O(k)`，因此其合并时间为`O(logk)`
- 由于每个节点最多`pop()`一次(因为权值排序已超过k，之后便不会再访问到该节点)，`pop()`总用时为`O(nlogk)`
- 初始化并查集、左式堆用时`O(n)`
- 每次合并时最多调用2次并查集查询、1次并查集合并与1次左式堆合并，因此总用时为
  `O(n+(m+q)logk+nlogk)` = `O((n+m+q)logk)`.

(2)空间复杂度

共涉及n个节点、n个左式堆，并查集的`parent[]`数组、记录集合大小的`sz[]`数组与路径压缩使用的`path[]`数组规模均为n，因此空间复杂度为`O(n)`.

## 6.参考资料

参考讲义中左式堆合并的实现
